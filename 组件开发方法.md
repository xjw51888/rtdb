
          
# ETL设计器和执行器中增加组件及组件开发指南

基于对代码库的分析，我将详细介绍如何在ETL设计器和执行器中增加新组件以及组件开发的完整流程。

## 一、ETL组件架构概述

ETL组件采用前后端分离的架构设计：

1. **后端架构**：
   - 基于Java开发，位于`etlwidget-base`模块
   - 采用继承体系，以`AbstractEtlWidget`为核心基类
   - 分为Source（数据源）、Processor（处理器）和Target（数据目标）三种类型

2. **前端架构**：
   - 基于JavaScript开发，位于`etldesigner-web`模块
   - 以`EtlWidget`为前端组件基类
   - 通过配置化方式定义组件属性和界面

## 二、后端组件开发步骤

### 1. 创建组件类

继承适当的基类，实现必要的接口和方法：

```java:g:/workspace/data-governance/etlwidget-base/src/main/java/com/dmp/edi/widget/base/job/自定义组件类名.java
@Component(自定义组件类名.WIDGET_TYPE)
@Scope(value = ConfigurableBeanFactory.SCOPE_PROTOTYPE)
public class 自定义组件类名 extends AbstractEtlWidget implements WidgetInfo {

    private static final long serialVersionUID = 1L; // 生成唯一序列化ID
    protected static final String WIDGET_TYPE = "自定义组件类型标识";
    
    // 组件特有属性
    private Widget自定义属性Ppt 属性代理 = new Widget自定义属性Ppt(this);
    
    public String getType() {
        return WIDGET_TYPE;
    }
    
    @Override
    public String getTypeCaption() {
        return I18N.getString("国际化键名", "组件显示名称");
    }
    
    // 核心处理方法
    public Query process(QueryRuntimeContext<EtlJobInfo> context) {
        // 实现组件的数据处理逻辑
        // 1. 获取输入组件
        EtlWidget input = context.getFirstInputWidget(this, true);
        // 2. 获取输入查询
        Query query = context.getQueryByWidgetName(input, this);
        // 3. 创建结果查询
        Query result = QueryFactory.create();
        // 4. 实现具体处理逻辑
        // 5. 返回处理结果
        return result;
    }
    
    // 其他自定义方法
}
```

### 2. 创建属性代理类

用于管理组件的配置属性：

```java:g:/workspace/data-governance/etlwidget-base/src/main/java/com/dmp/edi/widget/base/job/Widget自定义属性Ppt.java
public class Widget自定义属性Ppt {
    
    private AbstractEtlWidget widget;
    
    // 属性常量定义
    public static final String PROPERTY_NAME = "属性名";
    
    public Widget自定义属性Ppt(AbstractEtlWidget widget) {
        this.widget = widget;
    }
    
    // 属性的getter和setter方法
    public String get属性名() {
        return widget.getProperty(PROPERTY_NAME);
    }
    
    public void set属性名(String value) {
        widget.setProperty(PROPERTY_NAME, value);
    }
    
    // 其他属性处理方法
}
```

### 3. 实现校验逻辑

重写父类的validate方法进行数据校验：

```java
@Override
public void validate(ValidateResult result) {
    super.validate(result);
    // 实现组件特有的校验逻辑
    // 例如检查必要属性是否设置、表达式是否合法等
}
```

## 三、前端组件开发步骤

### 1. 创建组件JavaScript类

继承EtlWidget基类，实现界面和交互逻辑：

```javascript:g:/workspace/data-governance/etldesigner-web/src/main/resources/META-INF/resources/edi/widget/自定义路径/自定义组件文件名.js
define(
    ["edi/widget/base/job/etlwidget", "edi/editor/js/domutils", "eui/modules/edatalist"],
    function(etlwidget, domutils, edatalist) {
        "use strict";
        
        var EtlWidget = etlwidget.EtlWidget;
        var DomUtils = domutils.DomUtils;
        
        function 自定义组件类名(options) {
            // 组件配置信息
            this.config = {
                "属性1": "默认值1",
                "属性2": "默认值2",
                // 其他配置属性
            };
            
            // 调用父类构造函数
            EtlWidget.call(this, options);
        }
        
        // 继承EtlWidget
        EUI.extendClass(自定义组件类名, EtlWidget, "自定义组件类名");
        
        /**
         * 初始化组件界面
         */
        自定义组件类名.prototype._initDom = function() {
            // 创建组件配置页面
            this._initSettingsPage();
            // 创建字段列表页面
            this._initFieldsListPage();
            // 设置默认页面
            this.setActivePage(1);
        };
        
        /**
         * 初始化设置页面
         */
        自定义组件类名.prototype._initSettingsPage = function() {
            var settingPage = this.addPage(I18N.getString("国际化键名", "页面标题"));
            settingPage.style.cssText += ";padding:20px;";
            
            // 创建表单元素
            // ...
        };
        
        /**
         * 初始化字段列表页面
         */
        自定义组件类名.prototype._initFieldsListPage = function() {
            // 创建字段列表页面
            // ...
        };
        
        /**
         * 数据校验
         */
        自定义组件类名.prototype.checkData = function() {
            // 实现数据校验逻辑
            // ...
        };
        
        return {"自定义组件类名": 自定义组件类名};
    }
);
```

### 2. 配置组件元数据

在组件注册中心注册新组件：

1. **配置组件图标和分类**
2. **设置组件属性和默认值**
3. **定义组件的输入输出端口**

## 四、组件注册与部署

### 1. 后端注册

确保组件类添加了`@Component`注解，Spring容器会自动扫描并注册组件。

### 2. 前端注册

在前端组件注册配置中添加新组件的信息，包括组件名称、图标、分类等。

### 3. 部署流程

1. 编译打包修改后的代码
2. 部署更新到应用服务器
3. 清除浏览器缓存，刷新设计器页面

## 五、组件开发规范

### 1. 命名规范
- 类名：采用驼峰命名法，如`EtlWidgetFilter`
- 变量名：采用驼峰命名法，如`inputWidgets`
- 常量名：全部大写，下划线分隔，如`WIDGET_TYPE`

### 2. 代码规范
- 每个组件职责单一，专注于特定的数据处理功能
- 实现必要的接口和方法，遵循继承体系
- 添加适当的注释和国际化支持

### 3. 测试规范
- 编写单元测试验证组件的核心功能
- 在测试环境中进行集成测试
- 验证边界条件和异常情况

## 六、实例：开发一个简单的转换组件

以下是开发一个将字符串转换为大写的简单组件示例：

### 后端实现

```java
@Component(EtlWidgetUpperCase.WIDGET_TYPE)
@Scope(value = ConfigurableBeanFactory.SCOPE_PROTOTYPE)
public class EtlWidgetUpperCase extends AbstractEtlWidget implements WidgetInfo {

    private static final long serialVersionUID = 1L;
    protected static final String WIDGET_TYPE = "EtlWidgetUpperCase";
    
    @Override
    public String getType() {
        return WIDGET_TYPE;
    }
    
    @Override
    public String getTypeCaption() {
        return I18N.getString("com.dmp.edi.widget.base.job.etlwidgetuppercase.typecaption", "大写转换组件");
    }
    
    public Query process(QueryRuntimeContext<EtlJobInfo> context) {
        EtlWidget input = context.getFirstInputWidget(this, true);
        Query query = context.getQueryByWidgetName(input, this);
        
        Query result = QueryFactory.create();
        result.from(query);
        
        // 对所有字符串类型字段进行大写转换
        for (SqlField field : query.getAllFields(DefaultConnectionFactory.get(input.getDataSourceName(), true))) {
            if (isStringType(field.getType())) {
                result.addField("UPPER(" + field.getFullName() + ") AS " + field.getName());
            } else {
                result.addField(field);
            }
        }
        
        return result;
    }
    
    private boolean isStringType(int type) {
        // 判断是否为字符串类型
        return type == DbDefiner.FIELD_TYPE_STRING || type == DbDefiner.FIELD_TYPE_VARCHAR;
    }
}
```

### 前端实现

```javascript
define(
    ["edi/widget/base/job/etlwidget"],
    function(etlwidget) {
        "use strict";
        
        var EtlWidget = etlwidget.EtlWidget;
        
        function EtlWidgetUpperCase(options) {
            this.config = {};
            EtlWidget.call(this, options);
        }
        
        EUI.extendClass(EtlWidgetUpperCase, EtlWidget, "EtlWidgetUpperCase");
        
        EtlWidgetUpperCase.prototype._initDom = function() {
            var page = this.addPage(I18N.getString("edi.widget.base.job.etlwidgetuppercase.setting", "设置"));
            page.style.cssText += ";padding:20px;";
            
            var desc = page.appendChild(document.createElement("div"));
            desc.innerHTML = I18N.getString("edi.widget.base.job.etlwidgetuppercase.desc", "将输入的所有字符串字段转换为大写形式");
        };
        
        return {"EtlWidgetUpperCase": EtlWidgetUpperCase};
    }
);
```

## 七、总结

在ETL设计器和执行器中增加新组件需要完成以下核心步骤：

1. **后端开发**：创建组件Java类，继承适当的基类，实现数据处理逻辑
2. **前端开发**：创建组件JavaScript类，实现配置界面和用户交互
3. **组件注册**：在前后端框架中注册新组件
4. **测试部署**：验证组件功能并部署到生产环境

通过遵循上述开发流程和规范，可以高效地开发出符合系统要求的ETL组件，扩展ETL设计器和执行器的功能。
        